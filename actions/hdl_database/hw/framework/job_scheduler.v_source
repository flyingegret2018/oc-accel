`timescale 1ns/1ps
`define RETURN_CODE_ENABLE

module job_scheduler #(
    parameter HOST_DWIDTH = 1024,
    parameter RETURN_WIDTH = 41,
    parameter PASID_WIDTH = 9,
    parameter KERNEL_NUM = NUM_KERNELS
)(
                    input             clk                   ,
                    input             rst_n                 ,

                    //---- manager ----
                    output                            dsc0_pull_o     ,
                    input                             dsc0_ready_i    ,
                    input         [HOST_DWIDTH-1:0]   dsc0_data_i     ,
                    //---- completion ----
                    input                             complete_ready_i,
                    output    reg                     complete_push_o ,
                    output        [RETURN_WIDTH-1:0]  return_data_o   ,
                    //---- kernel ----
                    output    reg [KERNEL_NUM-1:0]    engine_start    ,
                    output    reg [HOST_DWIDTH-1:0]   jd_payload      ,
                `ifdef RETURN_CODE_ENABLE
                    input [KERNEL_NUM*(RETURN_WIDTH-64)-1:0] return_code,
                `endif
                    input         [KERNEL_NUM-1:0]    engine_done
                    );


//---- declarations ----
 reg    [KERNEL_NUM-1:0]    kernel_complete_prev;
 reg    [KERNEL_NUM-1:0]    kernel_busy;
 wire   [KERNEL_NUM-1:0]    kernel_complete_posedge;
 reg    [RETURN_WIDTH-1:0]  completion_info;
 reg    [5:0]               completion_kernel;
 reg    [KERNEL_NUM-1:0]    engine_done_r;

always@(posedge clk) if(dsc0_pull_o) jd_payload <= {dsc0_data_i[63:32],dsc0_data_i[1023:64],dsc0_data_i[1023:992]};
//: my $kn = NUM_KERNELS;
//: for (my $i = 0; $i < $kn; $i++) {
//:     print qq(
//:     reg [PASID_WIDTH+31:0] kernel${i}_info;
//:     always@(posedge clk) if(engine_start[$i]) kernel${i}_info <= {jd_payload[PASID_WIDTH-1:0],jd_payload[1023:992]};
//:     )
//: }

assign dsc0_pull_o = !(&kernel_busy) & dsc0_ready_i & !engine_start;
//assign complete_push_o = |(engine_done & kernel_busy);
assign return_data_o = completion_info;

genvar j;
generate
  for (j = 0; j < KERNEL_NUM; j = j + 1) begin:kernel_logic_gen
    always@(posedge clk or negedge rst_n)
        if(!rst_n)
            engine_done_r[j] <= 1'b0;
        else if(engine_start[j])
            engine_done_r[j] <= 1'b0;
        else if(engine_done[j])
            engine_done_r[j] <= 1'b1;

    always@(posedge clk or negedge rst_n)
        if(!rst_n)
            kernel_busy[j] <= 1'b0;
        else if(engine_start[j] == 1'b1)
            kernel_busy[j] <= 1'b1;
        else if(kernel_busy[j] & engine_done_r[j] & (completion_kernel == j) & complete_ready_i)
            kernel_busy[j] <= 1'b0;
  end
endgenerate

always@(posedge clk or negedge rst_n)
    if(!rst_n)
        completion_kernel <= 6'b0;
    else if(completion_kernel == KERNEL_NUM - 1)
        completion_kernel <= 6'b0;
    else if(|kernel_busy)
        completion_kernel <= completion_kernel + 1'b1;

always@(*)
    case(completion_kernel)
        //: my $kn = NUM_KERNELS;
        //: for (my $i = 0; $i < $kn; $i++) {
        //:     print qq(
        //:     $i: complete_push_o = engine_done_r[$i] & kernel_busy[$i] & complete_ready_i;
        //:     )
        //: }
        default: complete_push_o = 1'b0;
    endcase

`ifdef RETURN_CODE_ENABLE
always@(*)
    case(completion_kernel)
        //: my $kn = NUM_KERNELS;
        //: for (my $i = 0; $i < $kn; $i++) {
        //:     print qq(
        //:     $i: completion_info = {return_code[($i+1)*(RETURN_WIDTH-64)-1:$i*(RETURN_WIDTH-64)],{(32-PASID_WIDTH){1'b0}},kernel${i}_info};
        //:     )
        //: }
        default: completion_info = 'd0;
    endcase
`else
always@(*)
    case(completion_kernel)
        //: my $kn = NUM_KERNELS;
        //: for (my $i = 0; $i < $kn; $i++) {
        //:     print qq(
        //:     $i: completion_info = kernel${i}_info;
        //:     )
        //: }
        default: completion_info = 'd0;
    endcase
`endif

always@(posedge clk or negedge rst_n)
    if(!rst_n)
        engine_start <= 'd0;
    //: my $kn = NUM_KERNELS;
    //: for (my $i = 0; $i < $kn; $i++) {
    //:     print qq(
    //:     else if(dsc0_pull_o & (!kernel_busy[$i]))
    //:         engine_start <= 1 << $i;
    //:     )
    //: }
    else
        engine_start <= 'd0;

endmodule
